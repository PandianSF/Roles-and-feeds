"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTypeIdentifier = exports.binaryToHex = exports.convertBinaryToNumber = exports.convertHexToBinary = exports.convertTimestampToBinary = exports.convertClientIdToBinary = exports.clientIdFromBinary = exports.convertRepresentationToBinary = exports.binaryIDToURLSafe = exports.binaryIDToString = exports.binaryIDToHex = exports.binaryIDToDecimal = void 0;
const character_map_1 = require("./character_map");
const utils_1 = require("./utils");
function binaryIDToDecimal(value) {
    if (!(0, utils_1.checkIdLength)(value))
        throw new Error('Invalid ID');
    return BigInt('0b' + value);
}
exports.binaryIDToDecimal = binaryIDToDecimal;
function binaryIDToHex(value) {
    if (!(0, utils_1.checkIdLength)(value))
        throw new Error('Invalid ID');
    return binaryToHex(value);
}
exports.binaryIDToHex = binaryIDToHex;
function binaryIDToString(value) {
    if (!(0, utils_1.checkIdLength)(value))
        throw new Error('Invalid ID');
    return value
        .match(/.{1,8}/g)
        .map((char) => String.fromCharCode(parseInt(char, 2)))
        .join('');
}
exports.binaryIDToString = binaryIDToString;
function binaryIDToURLSafe(value) {
    if (!(0, utils_1.checkIdLength)(value))
        throw new Error('Invalid ID');
    return `${value.length === 64 ? '00' : ''}${value}`
        .match(/.{1,6}/g)
        .map((char) => character_map_1.BASE64_CHARACTER_MAP[char])
        .join('');
}
exports.binaryIDToURLSafe = binaryIDToURLSafe;
function convertRepresentationToBinary(id, representation, typeIdentifier) {
    switch (representation) {
        case 'BINARY':
            return id;
        case 'DECIMAL':
            return decimalToBinary(id);
        case 'HEX':
            return hexToBinary(id);
        case 'STRING':
            return stringToBinary(id);
        case 'URLSAFE':
            return urlsafeToBinary(id);
        default:
            throw new Error(`Invalid representation: ${representation}`);
    }
}
exports.convertRepresentationToBinary = convertRepresentationToBinary;
function decimalToBinary(id) {
    // Whatever be the input convert it to a binary string.
    const retVal = id.toString(2);
    if (!(0, utils_1.checkIdLength)(retVal)) {
        throw Error('Invalid ID passed for transformation.');
    }
    return retVal;
}
function hexToBinary(id) {
    const retVal = BigInt(`0x${id}`).toString(2);
    if (!(0, utils_1.checkIdLength)(retVal)) {
        throw Error('Invalid ID passed for transformation.');
    }
    return retVal;
}
function stringToBinary(id) {
    const retVal = id
        .split('')
        .map((char) => char.charCodeAt(0).toString(2))
        .join('');
    if (!(0, utils_1.checkIdLength)(retVal)) {
        throw Error('Invalid ID passed for transformation.');
    }
    return retVal;
}
function urlsafeToBinary(id) {
    // split the string character by character and do a reverse lookup for each character in BASE64_CHARACTER_MAP
    const retVal = id
        .split('')
        .map((char) => character_map_1.BASE64_CHARACTER_MAP_INVERSE[char])
        .join('');
    if (!(0, utils_1.checkIdLength)(retVal)) {
        throw Error('Invalid ID passed for transformation.');
    }
    return retVal;
}
function clientIdFromBinary(id) {
    if (id.length !== 20) {
        throw new Error('Invalid clientId passed for transformation.');
    }
    // break the id into lengths of 5 and match it with BASE32_MAP_INVERSE
    return id
        .match(/.{1,5}/g)
        .map((char) => character_map_1.BASE32_MAP_INVERSE[char])
        .join('');
}
exports.clientIdFromBinary = clientIdFromBinary;
function convertClientIdToBinary(value) {
    return value
        .split('')
        .map((char) => character_map_1.BASE32_MAP[char])
        .join('');
}
exports.convertClientIdToBinary = convertClientIdToBinary;
function convertTimestampToBinary(value, length = 32) {
    if (!(0, utils_1.isNumeric)(value))
        throw new Error('Invalid Value Passed');
    return value.toString(2).padStart(length, '0');
}
exports.convertTimestampToBinary = convertTimestampToBinary;
function convertHexToBinary(value, length = 8) {
    return BigInt('0x' + value)
        .toString(2)
        .padStart(length, '0');
}
exports.convertHexToBinary = convertHexToBinary;
function convertBinaryToNumber(value) {
    return BigInt('0b' + value);
}
exports.convertBinaryToNumber = convertBinaryToNumber;
function binaryToHex(value) {
    return BigInt('0b' + value).toString(16);
}
exports.binaryToHex = binaryToHex;
function calculateTypeIdentifier(idInBinary) {
    return binaryToHex(idInBinary.slice(64, 72)).padStart(2, '0').toUpperCase();
}
exports.calculateTypeIdentifier = calculateTypeIdentifier;
//# sourceMappingURL=convertors.js.map