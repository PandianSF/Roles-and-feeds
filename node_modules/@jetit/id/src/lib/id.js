"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertRepresentationToBinary = exports.explainId = exports.validateId = exports.generateID = exports.validateShortId = exports.getShortIdComponents = exports.generateShortId = exports.generateRRN = void 0;
const checksum_1 = require("./checksum");
const convertors_1 = require("./convertors");
const utils_1 = require("./utils");
var rrn_1 = require("./rrn");
Object.defineProperty(exports, "generateRRN", { enumerable: true, get: function () { return rrn_1.generateRRN; } });
var short_id_1 = require("./short-id");
Object.defineProperty(exports, "generateShortId", { enumerable: true, get: function () { return short_id_1.generateShortId; } });
Object.defineProperty(exports, "getShortIdComponents", { enumerable: true, get: function () { return short_id_1.getShortIdComponents; } });
Object.defineProperty(exports, "validateShortId", { enumerable: true, get: function () { return short_id_1.validateShortId; } });
/**
 * ClientID is generated by the client and is used to identify the client
 * in the generation of the ID. It is a 4 character string that is generated
 * and it gives a measure of randomness to the ID generation.
 */
let clientId = (0, utils_1.generateClientId)();
/**
 * The epoch start duration is set to the beginning of 2022 rather than the
 * unix epoch since this is primarily used for generating IDs. Since ID generation
 * does not happen in the past but rather the future, this allows us to restrict
 * the size of the bits to 32 rather than a long timestamp.
 */
const epochStart = 1640995200; // UNIX epoch in GMT
/**
 * The sequence is a 7 bit character that is used to ensure that the same ID is not
 * generated twice in the same second. It is incremented by 1 every time the ID generation
 * is called in the same client
 */
let sequence = 0;
let previousCombination = '';
function generateID(representation, typeIdentifier) {
    if (typeIdentifier && !(0, utils_1.isHexByte)(typeIdentifier))
        throw new Error('Invalid Type Identifier');
    const signBit = '1';
    const timestamp = Math.floor(new Date().getTime() / 1000) - epochStart;
    const timstampInBits = (0, convertors_1.convertTimestampToBinary)(timestamp);
    /** Reset client ID if the sequence reaches 126 as it originates from 0 and goes all the way to 126 */
    if (sequence === 126) {
        console.warn('Sequence number has reached maximum value. Switching to a new clientId');
        clientId = (0, utils_1.generateClientId)();
        sequence = 0;
    }
    const clientIdInBits = (0, convertors_1.convertClientIdToBinary)(clientId);
    const combination = signBit + timstampInBits + clientIdInBits;
    if (previousCombination === combination) {
        sequence++;
    }
    else {
        previousCombination = combination;
        sequence = 0;
    }
    const sequenceInBits = (0, utils_1.getSequenceNumberInBits)(sequence);
    const checksum = (0, checksum_1.calculateChecksum)(combination + sequenceInBits, typeIdentifier);
    const finalGeneratedId = combination + sequenceInBits + checksum + (typeIdentifier ? (0, convertors_1.convertHexToBinary)(typeIdentifier) : '');
    switch (representation) {
        case 'DECIMAL':
            return (0, convertors_1.binaryIDToDecimal)(finalGeneratedId);
        case 'BINARY':
            return finalGeneratedId;
        case 'HEX':
            return (0, convertors_1.binaryIDToHex)(finalGeneratedId);
        case 'STRING':
            return (0, convertors_1.binaryIDToString)(finalGeneratedId);
        case 'URLSAFE':
            return (0, convertors_1.binaryIDToURLSafe)(finalGeneratedId);
        default:
            return finalGeneratedId;
    }
}
exports.generateID = generateID;
function validateId(id, representation, typeIdentifier) {
    if (typeIdentifier && !(0, utils_1.isHexByte)(typeIdentifier))
        throw new Error('Invalid Type Identifier');
    const idInBinary = (0, convertors_1.convertRepresentationToBinary)(id, representation, typeIdentifier);
    // Calculate checksum by taking the first 60 bits of the ID and the type identifier
    const checksum = (0, checksum_1.calculateChecksum)(idInBinary.slice(0, 60), typeIdentifier);
    // Check if the checksum is the same as the bits 61-64 of the ID
    return checksum === idInBinary.slice(60, 64);
}
exports.validateId = validateId;
function explainId(id, representation) {
    const idInBinary = (0, convertors_1.convertRepresentationToBinary)(id, representation);
    const timestampBigInt = (0, convertors_1.convertBinaryToNumber)(idInBinary.slice(1, 33));
    const timestamp = new Date((parseInt(timestampBigInt.toString(), 10) + epochStart) * 1000);
    const clientId = (0, convertors_1.clientIdFromBinary)(idInBinary.slice(33, 53));
    const sequence = (0, convertors_1.convertBinaryToNumber)(idInBinary.slice(53, 60));
    let typeIdentifier;
    if (idInBinary.length === 72) {
        typeIdentifier = (0, convertors_1.calculateTypeIdentifier)(idInBinary);
    }
    return {
        id: {
            binary: idInBinary,
            decimal: (0, convertors_1.binaryIDToDecimal)(idInBinary),
            hex: (0, convertors_1.binaryIDToHex)(idInBinary),
            string: (0, convertors_1.binaryIDToString)(idInBinary),
            urlsafe: (0, convertors_1.binaryIDToURLSafe)(idInBinary),
        },
        typeIdentifier: typeIdentifier,
        clientId: clientId,
        sequence: sequence,
        createdTimestamp: timestamp.getTime(),
        createdTimestampReadable: timestamp.toISOString(),
        representation: representation,
    };
}
exports.explainId = explainId;
/** Add exports from other files */
var convertors_2 = require("./convertors");
Object.defineProperty(exports, "convertRepresentationToBinary", { enumerable: true, get: function () { return convertors_2.convertRepresentationToBinary; } });
//# sourceMappingURL=id.js.map