"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShortIdComponents = exports.validateShortId = exports.generateShortId = void 0;
const checksum_1 = require("./checksum");
const convertors_1 = require("./convertors");
const utils_1 = require("./utils");
let shortClientId = (0, utils_1.generateShortClientId)();
let sequence = 0;
let previousCombination = '';
const epochStart = 1640995200; // UNIX epoch in GMT
function generateShortId(typeIdentifier) {
    if (typeIdentifier && !(0, utils_1.isHexByte)(typeIdentifier))
        throw new Error('Invalid Type Identifier');
    const timestamp = Math.floor(new Date().getTime() / 1000) - epochStart;
    const timetampInBits = (0, convertors_1.convertTimestampToBinary)(timestamp, 30);
    if (timetampInBits.length > 30)
        throw new Error('Timestamp is too large. This library has probably outlived its usefullness. Update the Epoch start time to the start of your system if you want to keep going.');
    /** Reset client ID if the sequence reaches 126 as it originates from 0 and goes all the way to 126 */
    if (sequence === 126) {
        console.warn('Sequence number has reached maximum value. Switching to a new clientId');
        shortClientId = (0, utils_1.generateShortClientId)();
        sequence = 0;
    }
    const clientIdInBits = (0, convertors_1.convertHexToBinary)(shortClientId, 8);
    const combination = timetampInBits + clientIdInBits;
    if (previousCombination === combination) {
        sequence++;
    }
    else {
        previousCombination = combination;
        sequence = 0;
    }
    const typeIdentifierInBits = (0, convertors_1.convertHexToBinary)(typeIdentifier, 6);
    const sequenceInBits = (0, utils_1.getSequenceNumberInBits)(sequence);
    const checksum = (0, checksum_1.calculateShortChecksum)(combination + sequenceInBits, typeIdentifierInBits);
    const finalGeneratedId = combination + sequenceInBits + checksum + typeIdentifierInBits;
    return (0, convertors_1.binaryIDToURLSafe)(finalGeneratedId);
}
exports.generateShortId = generateShortId;
function validateShortId(id) {
    try {
        const idInBinary = (0, convertors_1.convertRepresentationToBinary)(id, 'URLSAFE');
        const idPart = idInBinary.slice(0, 45);
        const inboundChecksum = idInBinary.slice(45, 48);
        const typeIdentifier = idInBinary.slice(48, 54);
        const calculatedChecksum = (0, checksum_1.calculateShortChecksum)(idPart, typeIdentifier);
        return inboundChecksum === calculatedChecksum;
    }
    catch (e) {
        return false;
    }
}
exports.validateShortId = validateShortId;
function getShortIdComponents(id) {
    const isValid = validateShortId(id);
    if (!isValid)
        return { isValid };
    const idInBinary = (0, convertors_1.convertRepresentationToBinary)(id, 'URLSAFE');
    const timestamp = new Date((parseInt(idInBinary.slice(0, 30), 2) + epochStart) * 1000);
    const typeIdentifier = (0, convertors_1.binaryToHex)(idInBinary.slice(48, 54)).toUpperCase();
    return {
        isValid,
        timestamp,
        typeIdentifier: typeIdentifier,
    };
}
exports.getShortIdComponents = getShortIdComponents;
//# sourceMappingURL=short-id.js.map