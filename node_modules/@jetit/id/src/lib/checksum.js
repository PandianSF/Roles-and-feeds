"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateShortChecksum = exports.calculateChecksum = void 0;
const convertors_1 = require("./convertors");
function calculateChecksum(value, typeIdentifier) {
    if (value.length !== 60)
        throw new Error('Invalid Value is Passed to checksum calculation');
    // This brings the total length to 64 bits or to 72 bits if type identifier is passed
    const valueInBits = '00' + value + (!!typeIdentifier ? (0, convertors_1.convertHexToBinary)(typeIdentifier) : '') + '00';
    const calculationArray = valueInBits.match(/.{1,8}/g);
    // Perform binary addition of all values in the array
    const result = calculationArray.reduce((acc, curr) => {
        return (parseInt(acc, 2) + parseInt(curr, 2)).toString(2);
    });
    // Break the resulting set into 2 parts of 4 bits each and perform binary XOR
    const resultArray = result.match(/.{1,4}/g);
    const finalResult = (parseInt(resultArray[0], 2) ^ parseInt(resultArray[1], 2)).toString(2);
    // Return the final result
    return finalResult.padStart(4, '0');
}
exports.calculateChecksum = calculateChecksum;
function calculateShortChecksum(value, typeIdentifier) {
    console.log(value, value.length);
    if (value.length !== 45)
        throw new Error('Invalid Value is Passed to checksum calculation');
    const valueToCalculateChecksum = value.padStart(45, '0') + typeIdentifier;
    const calculationArray = valueToCalculateChecksum.match(/.{1,6}/g);
    if (!calculationArray) {
        return '0';
    }
    const result = calculationArray.reduce((acc, curr) => {
        return (parseInt(acc, 2) + parseInt(curr, 2)).toString(2);
    });
    const resultArray = result.match(/.{1,3}/g);
    if (!resultArray) {
        return '0';
    }
    const finalResult = (parseInt(resultArray[0], 2) ^ parseInt(resultArray[1], 2)).toString(2);
    return finalResult.padStart(3, '0');
}
exports.calculateShortChecksum = calculateShortChecksum;
//# sourceMappingURL=checksum.js.map